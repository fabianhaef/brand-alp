<template>
    <div class="lightswitch-wrapper">
        <label :for="`${id}-label`" v-on="!isStatic ? { click: toggle } : {}">
            <slot name="label"></slot>
        </label>

        <div v-if="isStatic">
            <span
                style="margin: 0;"
                :class="['status', {
                    on: toBoolean(proxyValue),
                }]"
            ></span>
        </div>

        <div
            v-else
            :id="id"
            ref="container"
            tabindex="0"
            role="checkbox"
            class="lightswitch"
            :class="[{
                on: toBoolean(proxyValue),
                indeterminate: indeterminate,
                dragging: dragging,
                small: small,
                'extra-small': extraSmall,
            }]"
            :aria-labelledby="`${id}-label`"
            :aria-checked="proxyValue ? 'true' : (indeterminate ? 'mixed' : 'false')"
            @mouseup="onMouseUp"
            @keydown="onKeyDown"
        >
            <div ref="innerContainer" class="lightswitch-container">
                <div class="handle"></div>
            </div>

            <!-- The server-side can be picky about `false` being an actual truthy value -->
            <input :value="proxyValue ? '1' : ''" :name="name" type="hidden">
        </div>
    </div>
</template>

<script>
import { toBoolean } from '@utils/bool';

export default {
    name: 'LightswitchField',

    props: {
        name: {
            type: String,
            default: '',
        },

        small: {
            type: Boolean,
            default: false,
        },

        extraSmall: {
            type: Boolean,
            default: false,
        },

        modelValue: {
            type: Boolean,
            default: false,
        },

        isStatic: {
            type: Boolean,
            default: false,
        },
    },

    emits: ['update:modelValue'],

    data() {
        return {
            id: `lightswitch-${Craft.randomString(10)}`,
            dragger: null,
            dragging: false,
            innerStyle: {},
            proxyValue: false,
            indeterminate: false,
        };
    },

    computed: {
        offMargin() {
            if (this.small) {
                return -10;
            }

            return -12;
        },
    },

    watch: {
        proxyValue(newValue) {
            this.$emit('update:modelValue', newValue);
        },
    },

    created() {
        this.proxyValue = this.modelValue;
    },

    mounted() {
        const { container } = this.$refs;

        this.$nextTick(() => {
            const lightswitch = $(container).data('lightswitch');
            if (lightswitch) {
                lightswitch.destroy();
            }

            this.dragger = new Garnish.BaseDrag(container, {
                axis: Garnish.X_AXIS,
                ignoreHandleSelector: null,
                onDragStart: this.onDragStart.bind(this),
                onDrag: this.onDrag.bind(this),
                onDragStop: this.onDragStop.bind(this),
            });
        });
    },

    beforeUnmount() {
        if (this.dragger) {
            this.dragger.destroy();
        }
    },

    methods: {
        turnOn() {
            this.proxyValue = true;
            this.indeterminate = false;
            this.dragging = true;

            const { innerContainer } = this.$refs;
            const animateCss = {
                [`margin-${Craft.left}`]: 0,
            };

            $(innerContainer).velocity('stop').velocity(animateCss, Craft.LightSwitch.animationDuration, this.onSettle.bind(this));
        },

        turnOff() {
            this.proxyValue = false;
            this.indeterminate = false;
            this.dragging = true;

            const { innerContainer } = this.$refs;
            const animateCss = {
                [`margin-${Craft.left}`]: this.offMargin,
            };

            $(innerContainer).velocity('stop').velocity(animateCss, Craft.LightSwitch.animationDuration, this.onSettle.bind(this));
        },

        toggle() {
            if (this.indeterminate || !this.proxyValue) {
                this.turnOn();
            } else {
                this.turnOff();
            }
        },

        onMouseUp() {
            // Was this a click?
            if (!this.dragger.dragging) {
                this.toggle();
            }
        },

        onKeyDown(event) {
            switch (event.keyCode) {
            case Garnish.SPACE_KEY: {
                this.toggle();
                event.preventDefault();
                break;
            }
            case Garnish.RIGHT_KEY: {
                if (Craft.orientation === 'ltr') {
                    this.turnOn();
                } else {
                    this.turnOff();
                }

                event.preventDefault();
                break;
            }
            case Garnish.LEFT_KEY: {
                if (Craft.orientation === 'ltr') {
                    this.turnOff();
                } else {
                    this.turnOn();
                }

                event.preventDefault();
                break;
            }
            }
        },

        onDragStart() {
            this.dragging = true;
            this.dragStartMargin = this.getMargin();
        },

        onDrag() {
            let margin;

            if (Craft.orientation === 'ltr') {
                margin = this.dragStartMargin + this.dragger.mouseDistX;
            } else {
                margin = this.dragStartMargin - this.dragger.mouseDistX;
            }

            if (margin < this.offMargin) {
                margin = this.offMargin;
            } else if (margin > 0) {
                margin = 0;
            }

            const { innerContainer } = this.$refs;
            $(innerContainer).css(`margin-${Craft.left}`, margin);
        },

        onDragStop() {
            const margin = this.getMargin();

            if (margin > (this.offMargin / 2)) {
                this.turnOn();
            } else {
                this.turnOff();
            }
        },

        onSettle() {
            this.dragging = false;
        },

        getMargin() {
            const { innerContainer } = this.$refs;
            const style = innerContainer.currentStyle || window.getComputedStyle(innerContainer);

            return parseInt(style.marginLeft);
        },

        toBoolean(value) {
            return toBoolean(value);
        },
    },

};

</script>


<style lang="scss">

.lightswitch-wrapper {
    display: flex;
    align-items: center;
}

//
// Extra Small Lightswitch
//

.lightswitch.extra-small {
    border-radius: 7px;
    width: 24px;
    min-width: 24px;
    height: 14px;
}

.lightswitch.extra-small .lightswitch-container {
    width: 34px;
}

.lightswitch.extra-small .lightswitch-container .handle {
    border-radius: 8px;
    width: 12px;
    height: 12px;
    left: calc(50% - 4px);
}

.lightswitch.extra-small.on .lightswitch-container .handle {
    left: calc(50% - 6px);
}
</style>
